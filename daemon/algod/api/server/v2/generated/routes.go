// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Get the state proof transaction for a given round
	// (GET /v2/transactions/state-proof/{round})
	StateProof(ctx echo.Context, round uint64) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.GET("/v2/transactions/state-proof/:round", wrapper.StateProof, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"MEvJzjFf+bsP/z8AAP//8eseHbEeAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"BQAA//9nht2R2esAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

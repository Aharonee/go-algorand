// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"h3cf/38AAAD//4XLwRkvKAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

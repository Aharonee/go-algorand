// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"l1KyM3zG4d3H/x8AAP//otundigsAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

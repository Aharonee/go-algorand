// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/f8AAAD//2IkgBgW/wAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//9FVIwP9fUAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

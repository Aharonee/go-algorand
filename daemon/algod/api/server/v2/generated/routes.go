// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

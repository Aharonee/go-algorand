// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"e1fksu4AAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

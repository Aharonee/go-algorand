// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

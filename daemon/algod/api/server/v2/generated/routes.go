// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

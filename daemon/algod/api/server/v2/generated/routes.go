// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
